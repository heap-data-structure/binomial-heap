<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/BinomialHeap.js | @heap-data-structure/binomial-heap</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-style.css"><script src="./inject/script/0-header.js"></script><meta name="description" content="Binomial heap data structures for JavaScript"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@heap-data-structure/binomial-heap"><meta property="twitter:description" content="Binomial heap data structures for JavaScript"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/heap-data-structure/binomial-heap"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-BinomialHeap">BinomialHeap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-BinomialTree">BinomialTree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-BinomialTreeWithParent">BinomialTreeWithParent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-LazyBinomialHeap">LazyBinomialHeap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-LazyNode">LazyNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-LazyStack">LazyStack</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/BinomialHeap.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">export default function BinomialHeap(BinomialTree) {
	const binomial_heap_push = function (compare, list, tree, rank) {
		// Ensures list has at least rank cells

		let i = rank - list.length;

		while (i-- &gt; 0) {
			list.push(null);
		}

		// Loop invariant
		// tree and list[i] have the same rank

		const len = list.length;

		for (i = rank; i &lt; len &amp;&amp; list[i] !== null; ++i) {
			// There is already a tree with this rank

			tree = tree.merge(compare, list[i]);
			list[i] = null;
		}

		// Do not forget to append null if
		// we are lacking space

		if (i === len) {
			list.push(null);
		}

		// Cell is empty
		// we can just put the new tree here

		list[i] = tree;
	};

	const merge = function (compare, list, other) {
		if (other.length === 0) {
			return;
		}

		// Merging two binomial heaps is like
		// adding two little endian integers
		// so, we first make sure that we have
		// enough place to store the result

		let i = other.length - list.length;

		while (i-- &gt; 0) {
			list.push(null);
		}

		let carry = null;

		const len = list.length;

		// Remember len &gt;= other.length

		for (i = 0; i &lt; len; ++i) {
			// Other[i] can be either null or not
			// list[i] can be either null or not
			// carry can be either null or not
			// --&gt; 2^3 = 8 possibilities
			//
			//    null ? | other[i] | list[i] | carry
			// ---------------------------------------
			//     (0)   |    no    |     no  |   no
			//     (1)   |    no    |     no  |  yes
			//     (2)   |    no    |    yes  |   no
			//     (3)   |    no    |    yes  |  yes
			//     (4)   |   yes    |     no  |   no
			//     (5)   |   yes    |     no  |  yes
			//     (6)   |   yes    |    yes  |   no
			//     (7)   |   yes    |    yes  |  yes

			if (i &gt;= other.length || other[i] === null) {
				if (carry !== null) {
					// (6) other[i] = null and list[i] = null and carry != null
					// --&gt; put carry in current cell

					if (list[i] === null) {
						list[i] = carry;
						carry = null;
					}

					// (4) other[i] = null and list[i] != null and carry != null
					// --&gt; merge carry with current cell
					else {
						carry = carry.merge(compare, list[i]);
						list[i] = null;
					}
				}

				// We do not need to do anything for
				// those 2 cases (carry and other[i] are null).
				// ==
				// (5) other[i] = null and list[i] != null and carry = null
				// (7) other[i] = null and list[i] = null and carry = null
			}

			// (0) other[i] != null and list[i] != null and carry != null
			// (2) other[i] != null and list[i] = null and carry != null
			// --&gt; merge carry with other[i]
			else if (carry !== null) {
				carry = carry.merge(compare, other[i]);
			}

			// (1) other[i] != null and list[i] != null and carry = null
			// --&gt; merge current cell with other[i]
			else if (list[i] !== null) {
				carry = list[i].merge(compare, other[i]);
				list[i] = null;
			}

			// (3) other[i] != null and list[i] = null and carry = null
			// --&gt; put other[i] in list
			else {
				list[i] = other[i];
			}
		}

		// Do not forget to append last carry

		if (carry !== null) {
			list.push(carry);
		}
	};

	const find_min_index = function (compare, list, j, len) {
		// There MUST be at least one
		// non null element in this list
		// we look for the first one

		for (; j &lt; len - 1 &amp;&amp; list[j] === null; ++j);

		// Here j is necessarily &lt; len
		// and list[j] is non null

		let i = j;
		let opt = list[j].value;

		// We lookup remaining elements to see if there
		// is not a better candidate

		for (++j; j &lt; len; ++j) {
			const item = list[j];

			if (item !== null) {
				const candidate = item.value;

				if (compare(candidate, opt) &lt; 0) {
					i = j;
					opt = candidate;
				}
			}
		}

		return i;
	};

	const remove_head_at_index = function (compare, list, i, len) {
		const orphans = list[i].children;
		list[i] = null;

		change_parent(null, orphans);

		// We just removed the ith element
		// if list[i] is the last cell
		// of list we can drop it

		if (i === len - 1) {
			list.pop();
		}

		// We merge back the children of
		// the removed tree into the heap

		merge(compare, list, orphans);
	};

	const binomial_heap_pop = function (compare, list) {
		const len = list.length;

		const i = find_min_index(compare, list, 0, len);

		const tree = list[i];

		remove_head_at_index(compare, list, i, len);

		return tree;
	};

	const change_parent = function (parent, children) {
		const len = children.length;

		for (let i = 0; i &lt; len; ++i) {
			children[i].setparent(parent);
		}
	};

	const shift_up = function (tree, parent) {
		// Console.log( &quot;tree&quot;, tree.value );
		// console.log( &quot;parent&quot;, parent.value );

		// Here, we cannot just swap values as it would invalidate
		// externally stored references.
		// Instead, we swap children lists and update references
		// between the tree and its parent.
		// Then we update and return the new tree&apos;s parent.

		// console.log( &quot;tree.children&quot;, tree.children );
		// console.log( &quot;parent.children&quot;, parent.children );

		const tmp = parent.children;
		parent.children = tree.children;
		tree.children = tmp;

		const i = parent.rank();

		// Console.log( tree.children, i );

		tree.children[i] = parent;

		tree.parent = parent.parent;

		change_parent(tree, tree.children);
		change_parent(parent, parent.children);

		// Console.log( &quot;tree.children&quot;, tree.children );
		// console.log( &quot;parent.children&quot;, parent.children );

		return tree.parent;
	};

	const percolate_up = function (list, tree) {
		let parent = tree.parent;

		if (parent !== null) {
			while (true) {
				parent = shift_up(tree, parent);

				if (parent === null) {
					break;
				}

				// TODO this call might not be necessary
				parent.children[tree.rank()] = tree;
			}

			list[tree.rank()] = tree;
		}
	};

	const decreasekey = function (compare, list, tree, value) {
		tree.value = value;
		let parent = tree.parent;

		if (parent !== null) {
			while (true) {
				const d = compare(value, parent.value);

				if (d &gt;= 0) {
					return;
				}

				parent = shift_up(tree, parent);

				if (parent === null) {
					break;
				}

				// TODO this call should be in if ( d &gt;= 0 )
				parent.children[tree.rank()] = tree;
			}

			list[tree.rank()] = tree;
		}
	};

	const deletetree = function (compare, list, tree) {
		percolate_up(list, tree);

		remove_head_at_index(compare, list, tree.rank(), list.length);

		tree.detach();
	};

	const Heap = function (compare) {
		// The compare function to use to compare values

		this.compare = compare;

		// Number of elements in this heap

		this.length = 0;

		// List of binomial trees

		this.list = [];
	};

	Heap.prototype.head = function () {
		if (this.length === 0) {
			return undefined;
		}

		const i = find_min_index(this.compare, this.list, 0, this.list.length);

		const tree = this.list[i];

		return tree.value;
	};

	Heap.prototype.headreference = function () {
		if (this.length === 0) {
			return null;
		}

		const i = find_min_index(this.compare, this.list, 0, this.list.length);

		const tree = this.list[i];

		return tree;
	};

	Heap.prototype.pop = function () {
		if (this.length === 0) {
			return undefined;
		}

		--this.length;

		return binomial_heap_pop(this.compare, this.list).value;
	};

	Heap.prototype.popreference = function () {
		if (this.length === 0) {
			return null;
		}

		--this.length;

		return binomial_heap_pop(this.compare, this.list).detach();
	};

	Heap.prototype.push = function (value) {
		// Push a new tree of rank 0

		const tree = new BinomialTree(value, []);

		this.pushreference(tree);

		return tree;
	};

	Heap.prototype.pushreference = function (tree) {
		++this.length;

		// Push an existing tree of rank 0

		binomial_heap_push(this.compare, this.list, tree, 0);
	};

	Heap.prototype.merge = function (other) {
		merge(this.compare, this.list, other.list);

		this.length += other.length;

		return this;
	};

	Heap.prototype.update = function (tree, value) {
		const d = this.compare(value, tree.value);

		if (d &lt; 0) {
			this.decreasekey(tree, value);
		} else if (d &gt; 0) {
			this.increasekey(tree, value);
		} else {
			// D === 0 does not imply tree.value === value

			tree.value = value;
		}
	};

	Heap.prototype.decreasekey = function (tree, value) {
		decreasekey(this.compare, this.list, tree, value);
	};

	Heap.prototype.increasekey = function (tree, value) {
		deletetree(this.compare, this.list, tree);

		tree.value = value;

		binomial_heap_push(this.compare, this.list, tree, 0);
	};

	Heap.prototype.delete = function (tree) {
		--this.length;

		deletetree(this.compare, this.list, tree);
	};

	return Heap;
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
